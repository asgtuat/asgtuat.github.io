<!doctype html>
<html lang="ja">
  <head>
    <meta charset="utf-8">
    <title>知能情報システム工学実験 1A(プログラムの動作原理)</title>
    <link rel="stylesheet" type="text/css" href="./asg.css">
  </head>
  <body>
    
    <table align="center" width="1000px">

      <tr><td>
	  
	  <h1>知能情報システム工学実験 1A(プログラムの動作原理)</h1>
	  
	  <div>
	    <p>本課題の目的は，プログラムがどのようにコンピュータ上で動作しているか，および広く利用されている x86 のアセンブラに触れ，実機上でプログラムがどのように動作しているかを理解し，実感することである．これまで C 言語のプログラミングや計算機アーキテクチャなどの講義で，コンピュータ上でのプログラムの動作イメージをぼんやりと掴んでいるかもしれない．本課題では，プログラムがどのようにメモリ上に展開され，それらを CPU がどのように実行しているか，そのイメージをよりはっきりさせる．たとえば，再帰関数がコンピュータ上でどのように実行されているか，局所変数，大域変数がメモリ上にどのように配備されているか，を具体的に知る．本実験を通してこれまで学んできたプログラムとコンピュータの動作原理とが結びつき，コンピュータ全体の動作理解の一助となれば幸いである．</p>
	  </div>
	  <br>
	  <ul>
	      <li class="index">説明(プログラムの動き)</li>
	      <li class="index"><a class="index" href="x86.html">説明(x86)</a></li>
	      <li class="index"><a class="index" href="slide.html">説明スライド</a></li>
	      <li class="index"><a class="index" href="assignment.html">課題</a></li>
	      <li class="index"><a class="index" href="submit.html">レポートの提出</a></li>
	    </ul>
	      <br><hr color="blue">

	      <h2>プログラムとコンピュータ</h2>

	  <p>本課題では，これまで独立して学んできたプログラミングとコンピュータ()との理解を結びつけることを狙いとし，コンピュータ全体の動作の理解を深める．本学科の講義において，プログラムの制御構文やデータ構造を勉強し，C 言語や Java，Python を用いてプログラムを作り，コンピュータ上で動作させながらその理解を深めてきた．一方で，プログラムを実行するコンピュータは，前回の実験や計算機アーキテクチャで学んだように，メモリ上に配置された命令を CPU が取得(fetch)し，それを解釈(decode)，実行(execute)し，プログラムカウンタが示すアドレスを 1 進める．では，自分の作ったプログラム(大域変数や局所変数，制御構文など)がどのような形でメモリ上に配備され，CPU はそのプログラムはどのように実行しているのだろうか．</p>
	  <center>
	    <img src="./fig1.png" width="50%">
	  </center>
	<p> コンピュータ全体の動作の理解は本課題をこなせば確実に深まるが，すべてを理解するためにはまだ知識が足りないのが現実である．プログラムはどのようにコンパイルされるのか，なぜ複数のプログラムが動作しているのか，どのように他のコンピュータと通信しているのか，など疑問はたくさんある．これらのトピックについては，3年次に開講される，言語処理やオペレーティングシステム，計算機ネットワークについて触れる．常にコンピュータ全体の動作を意識すると，理解がしやすいと思う．お楽しみに．</p>
	      
	      <h2>メモリ上のプログラム</h2>
	  <p>プログラムがメモリ上に配備された様子を図に示す．プログラムは大きく次の 3 つの領域によって構成される．それぞれ詳細を見ていく．</p>
	  <center>
	  <img src="./fig2.png" width="50%">
	  </center>
	    <ol>
	      <li><b>テキスト(コード)領域:</b> コンパイルによって生成された機械語を格納するための領域．プログラムカウンタはこの領域を指し，命令を実行する．</li><br>
	      
		<li><b>データ領域:</b> プログラムが参照するデータを格納するための領域．スタティック変数やグローバル変数，動的に確保したメモリ領域(malloc()などで確保した領域)などが含まれ，機械語から参照されながら使用される．</li><br>

		<li><b>スタック領域:</b> 各プログラムに与えられたスタックを格納するための領域．関数の戻り番地や局所変数が格納される．データ構造で学んだスタックを巧みに使う．</li> <br>
	      </ol>

	      
	  <h3>テキスト領域</h3>
	  <p>機械語が格納されており，プログラムカウンタは常にテキスト領域を指しており，他領域を指すことはまずない．不正な書き換えを防止するために，読み込み専用になっていることが普通である．</p>
	  
	  <h3>データ領域</h3>
	  <p>機械語が参照するデータが格納されている．データ領域はデータの種類によって，さらに 3 つの領域に別れている．</p>
	    <ol>
	      <li><b>データ(data):</b>  初期化されたグローバル変数・スタティック変数を格納する領域．</li><br>
	      <li><b>BSS(Block Started by Symbol):</b>  初期化されていないグローバル変数・スタティック変数を格納する領域．</li><br>
	      <li><b>ヒープ(heap):</b>  動的に確保されるメモリを格納する領域．動作とともにヒープ領域は大きくなったり(malloc()で確保)，小さくなったり(free()で開放)する．</li><br>
	    </ol>

	  <p>ここで，次の<a href="./program/sample1.c">プログラム</a>を考える．異なる種類のデータを用意し，そのアドレスを表示するプログラムである．</p>
<div class="code">
<pre>
<code>
#include &ltstdio.h&gt
#include &ltstdlib.h&gt

int a;
int b = 100;
static int c = 100;
static int d;

int main()
{
	int *e, *f;
	e = malloc(sizeof(int));
	f = malloc(sizeof(int));

	printf("a's address = %p\n", &a);
	printf("b's address = %p\n", &b);
	printf("c's address = %p\n", &c);
	printf("d's address = %p\n", &d);
	printf("e's address = %p\n", e);
	printf("f's address = %p\n", f);

	return 0;
}
</code>
</pre>
</div>
<p>
  出力は次のようになった．
</p>
<div class="code">
<pre>
 <code>
a's address = 0x1013e802c
b's address = 0x1013e8020
c's address = 0x1013e8024
d's address = 0x1013e8028
e's address = 0x7fded2c04b10
f's address = 0x7fded2c04b20
 </code>
</pre>
</div>
<p>初期化された b と c の後に，初期化されていない a と c が配備され，そのずっと後方に動的に確保した e と f がある．</p>

	  <center>
	    <img src="./fig3.png" width="50%">
	  </center>


<h3>スタック領域</h3>
	  <p>スタックと聞くと，Last in, First out(LIFO) を想像するであろう．スタック領域は LIFO の動作をしながら，本領域は関数呼び出しを実現する上で重要な役割を果たす．スタック領域には，関数の戻りアドレスや局所変数，関数への引数が格納され，テキスト領域に格納されている機械語から適宜参照される．関数を呼び出してから，その関数から返ってくるまで，スタック以下のように利用される．</p>

	  <ol>
	    <li>関数が呼び出されると，引数の値と関数実行後に実行する機械語のアドレス(= 戻りアドレス)をスタックに格納する．</li><br>

	    <li>呼び出し先の関数の局所変数の領域を確保する．加えて，使用するレジスタの値をスタックに退避する．レジスタ値の退避は，
	      レジスタの値を関数を呼び出す前の状態に戻すために行う．これを行わないと，呼び出し元の関数に戻ったときに，
	      呼び出し先の関数でのレジスタ値を使うことになり，関数終了後に演算を正しく再開できない．</li><br>

	    <li>関数実行終了後，スタックに退避したレジスタ値を各該当レジスタに復元する．</li><br>

	    <li>スタック内の戻りアドレスにジャンプして，呼び出し元の関数を実行する．</li><br>
	  </ol>

	  <p>たとえば次の関数呼び出しを伴う<a href="./program/sample2.c">プログラム</a>を考える．配列とそのサイズを引数として受け取り，配列の要素の和を返す sum() があり，1 から 10 の整数の和を計算している．</p>
<div class="code">
	  <pre>
	    <code>
 1	#include &ltstdio.h&gt
 2
 3	int sum(int a[], int size)
 4	{
 5		int i, ret = 0;
 6
 7		for (i = 0; i < size; i++)
 8			ret += a[i];
 9
10		return ret;
11	}
12
13	int main(int argc, char **argv)
14	{
15		int i, a[10], a_sum;
16
17		for (i = 0; i < 10; i++)
18			a[i] = i + 1;
19
20		a_sum = sum(a, 10);
21		printf("%d\n", a_sum);
22
23		return 0;
24	}
</code>
 </pre>
</div>
	  <p>このプログラムを実行したときのスタックのおおざっぱな変化を下図に示す．簡単のため，レジスタの退避・復元は省略してある．プログラムが起動すると，main() にジャンプする．この際，main() の引数，main() を呼んだ関数への戻りアドレス，main() の局所変数がスタックに積まれる．ある関数を呼び出したときにスタックに積まれる一連のデータをまとめて<b>スタックフレーム</b>と呼ぶ．スタックに一連の情報が積まれたら main() を実行していき，配列 a の初期化が終わると，sum() を呼び出す(17〜20行目)．そして，sum() にジャンプするときには，スタックに引数(a, 10)，戻り番地(21行目に相当するアドレス)，そして sum() の局所変数(i, ret)が積まれる．関数実行後は，スタック上に保存されているの戻り番地へジャンプし，sum() を呼び出すときに生成したスタックフレームを開放する．</p>
	  
	  <center>
	    <img src="./fig4.png" width="50%">
	  </center>

	  <p>もう少し複雑な例を考える．たとえば，再帰を利用する<a href="./program/sample3.c">プログラム</a>を考える．以下のプログラムのように，階乗を求める fact() が再帰を利用して記述されており，5 の階乗が出力される．</p>
<div class="code">
	  <pre>
	    <code>
 1	#include &ltstdio.h&gt
 2
 3	int fact(int num)
 4	{
 5		int ret;
 6
 7		if (num == 1) ret = 1;
 8		else	      ret = num * fact(num - 1);
 9
10		return ret;
11	}
12
13	int main()
14	{
15		int vaule;
16
17		vaule = fact(4);
18		printf("%d\n", value);
19		return 0;
20	}
</code>
 </pre>
</div>
	  <p>このプログラムを実行したときのスタックのおおざっぱな挙動を図xxx に示す．簡単のため，レジスタの退避・復元は省略してある．プログラムが起動すると，main() が呼ばれてスタック上に value という局所変数の領域が設けられる(13〜15行目)．次に，fact()が呼ばれる(17行目)．ここで，fact()にジャンプするわけだが，このときに関数の戻りアドレスとなるアドレス(18行目に相当するアドレス)と引数として渡した 4 の値がスタック上に積まれる．その後，fact()を実行する前に局所変数 ret の領域が同様にスタック上に確保される(5行目)．今，num = 5 なので，else の方が実行され，fact(3)が呼び出される(8行目)．すると，同様に引数の値，戻り番地，そして局所変数 ret の領域がスタックに設けられる．これが，fact(2)，fact(1)と繰り返される．fact(1)を実行するときに ret に 1 が代入されて，それが返り値になる．すると，fact(1)が終了し，fact(1)へジャンプするときにスタックに積んだ戻り番地に戻る(fact(2)実行時の8行目)．すると，ret には 2(num) × 1(fact(1)の返り値) = 2 が入り，fact(2)は終了する．すると，次は fact(2)へジャンプするときに記録した戻り番地へと戻る(fact(3)実行時の8行目)．同様に，ret には 3(num) × 2(fact(2)の返り値) = 6 が入り，fact(4)と戻っていく．
	  </p>
	  <center>
	    <img src="./fig5.png" width="50%">
	  </center>

	  <p>こうした挙動はどの CPU にも当てはまるが，細やかな挙動は CPU アーキテクチャに依存する．たとえば，汎用レジスタはいくつあるのか，どのレジスタに関数の返り値を格納するのか，スタックポインタ，プログラムカウンタの名称などである．関数の呼び出し規約については，CPU のマニュアルに記述されている．
	  </p>


<h2></h2>

